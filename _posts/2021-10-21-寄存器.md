---
layout:    post
title:     寄存器 （CPU工作原理）
subtitle:  学习学习
date:      2021-10-21
author:    lll-yz
header-img: img/post-bg-coffee.jpg
catalog:    true
tags:

   - 汇编
---

## CPU概述

一个典型的CPU由运算器、控制器、寄存器等器件组成，这些器件靠内部总线相连。

**区别：**

内部总线实现CPU内部各个器件之间的联系。

外部总线实现CPU和主板上其它器件的联系。

## 寄存器概述

8086CPU有14个寄存器，它们的名称为：AX, BX, CX, DX, SI, DI, SP, BP, IP, CS, SS, DS, ES, PSW。

### 2.1通用寄存器

8086CPU所有的寄存器都是16位的，可以存放两个字节。

**AX, BX, CX, DX** 通常用来存放一般性数据被称为通用寄存器。

以 AX 为例，寄存器的逻辑结构：

[![5rqMpn.png](https://z3.ax1x.com/2021/10/21/5rqMpn.png)](https://imgtu.com/i/5rqMpn)

eg.一个16位寄存器可以存储一个16位的数据。(数据存放情况)

> 数据：18
>
> 二进制表示：10010
>
> 在寄存器 AX 中的存储：
>
> [![5rqHAg.png](https://z3.ax1x.com/2021/10/21/5rqHAg.png)](https://imgtu.com/i/5rqHAg)

一个16位寄存器所能存储的数据的最大值为：2^16-1。

为保证兼容性，这四个寄存器都可以分为两个独立的8位寄存器使用。

+ AX 可以分为 AH 和 AL；   (H: 高位，L：低位)
+ BX 可以分为 BH 和 BL；
+ CX 可以分为 CH 和 CL；
+ DX 可以分为 DH 和 DL。

以 AX 为例，8086CPU的16位寄存器分为两个8位寄存器的情况：

[![5rLRVU.png](https://z3.ax1x.com/2021/10/21/5rLRVU.png)](https://imgtu.com/i/5rLRVU)

AX 的低8位 (0位~7位) 构成了 AL 寄存器，高8位 (8位~15位) 构成了 AH 寄存器。

AH 和 AL 寄存器是可以独立使用的8位寄存器。

8086CPU的8位寄存器数据存储情况：

[![5rLvPH.png](https://z3.ax1x.com/2021/10/21/5rLvPH.png)](https://imgtu.com/i/5rLvPH)

一个8位寄存器所能存储的数据的最大值为：2^8-1。

### 2.2字在存储器中的存储

一个字可以存在一个16位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高8位寄存器和低8位寄存器中。

1 word = 2 Byte

由于一个内存单元可以存放8位数据，CPU中的寄存器又可存放n个8位数据。也就是说，计算机中的数据大多是由1~N个8位数据构成的。

用十六进制来表示数据可以直观的看出这个数据是由哪些8位数据构成的。

**每两位对应一个八进制！**

### 2.3几条汇编指令

[![5yVwS1.png](https://z3.ax1x.com/2021/10/21/5yVwS1.png)](https://imgtu.com/i/5yVwS1)

CPU执行下表中的程序段的每条指令后，对寄存器中的数据进行的改变：

[![5yZ39A.png](https://z3.ax1x.com/2021/10/21/5yZ39A.png)](https://imgtu.com/i/5yZ39A)

ax = 044CH  (1044CH，这里1无法存放了)

[![5yecRA.png](https://z3.ax1x.com/2021/10/21/5yecRA.png)](https://imgtu.com/i/5yecRA)

ax = 0158H

### 检测

1、写出每条汇编指令执行后相关寄存器中的值。

> mov ax, 62627		AX = F4A3H
>
> mov ah, 31H		    AX = 31A3H
>
> mov al, 23H			 AX = 3123H
>
> add ax, ax				AX = 6246H
>
> mov bx, 826CH	   BX = 826CH
>
> mov cx, ax				CX = 6246H
>
> mov ax, bx			   AX = 826CH
>
> add ax, bx				AX = 04D8H
>
> mov al, bh				AX = 0482H
>
> mov ah, bl				AX = 6C82H
>
> add ah, ah				AX = D882H
>
> add al, 6					AX = D888H
>
> add al, al 				  AX = D810H
>
> mov ax, cx				AX = 6246H

2、只能使用目前学过的汇编指令，最多使用四条指令，编程计算2的4次方。

> mov ax, 2
>
> add ax, ax
>
> add ax, ax
>
> add ax, ax

### 2.4物理地址

CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间。

我们将这个唯一的地址称为物理地址。

### 2.5 16位结构的CPU

概括的讲，16位结构描述了一个CPU具有以下几个方面特征：

+ 运算器一次最多可以处理16位的数据。
+ 寄存器的最大宽度为16位。
+ 寄存器和运算器之间的通路是16位的。

### 2.6 8086CPU给出物理地址的方法

+ 8086有20位地址总线，可传送20位地址，寻址能力为1M。
+ 8086内部为16位结构，它只能传送16位的地址，表现出的寻址能力却只有64K。

8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址：

[![5yUVmD.png](https://z3.ax1x.com/2021/10/21/5yUVmD.png)](https://imgtu.com/i/5yUVmD)

地址加法器合成物理地址的方法：

​		物理地址 = 段地址 + 偏移地址

[![5yUX9I.png](https://z3.ax1x.com/2021/10/21/5yUX9I.png)](https://imgtu.com/i/5yUX9I)

"段地址 * 16" 有一个更为常用的说法就是数据左移4位。(二进制位)

[![5ydpxx.png](https://z3.ax1x.com/2021/10/21/5ydpxx.png)](https://imgtu.com/i/5ydpxx)

我们通过观察位移次数和各种形式数据的关系：

1、一个数据的二进制形式左移1位，相当于该数据乘以2；

2、一个数据的二进制形式左移N位，相当于该数据乘以2的N次方；

3、地址加法器如何完成段地址 * 16的运算？

​		以二进制形式存放段地址左移4位。

经过进一步思考，我们可以得出：

1、一个数据的16进制形式左移1位，相当于乘以16；

2、一个数据的10进制形式左移1位，相当于乘以10；

3、一个数据的X进制形式左移1位，相当于乘以X。

### 2.7 "段地址*16 + 偏移地址 = 物理地址"的本质含义

"基础地址 + 偏移地址 = 物理地址"     比喻 ===>

[![5y0G2n.png](https://z3.ax1x.com/2021/10/21/5y0G2n.png)](https://imgtu.com/i/5y0G2n)

"段地址*16 + 偏移地址 = 物理地址"  比喻 ===>

觉得不怎么样，所以就不说了，阿巴阿巴阿巴......

### 2.8段的概念

错误认识：

​	内存被划分成了一个一个的段，每一个段有一个段地址。

其实：

​	内存并没有分段，段的划分来自于CPU，由于8086CPU用 "(段地址*16) + 偏移地址 = 物理地址" 的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。

以后，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址*16定位段的起始地址 (基础地址)，用偏移地址定段中的内存单元。

**两点需要注意：**

1、段地址*16必然是16的倍数，所以一个段的起始地址也一定是16的倍数。

2、偏移地址为16位，16位地址的寻址能力为64K，所以一个段的长度最大为64K。

